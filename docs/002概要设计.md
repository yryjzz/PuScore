# 1. 系统架构设计

## 1.1 整体架构（前后端分离 + 多端适配）

采用 “前端多端适配 + 后端复用 + 轻量数据库” 架构，核心分层如下：
┌─────────────────────────────────────────────────────────┐
│ 前端层（H5+Web 兼容） │
│ ┌─────────────┐ ┌─────────────┐ ┌─────────────────┐ │
│ │ 响应式适配层 │ │ 业务组件层 │ │ 工具服务层 │ │
│ │（屏幕判断/布局切换）│ │（多端共用组件）│ │（API/缓存/交互）│ │
│ └─────────────┘ └─────────────┘ └─────────────────┘ │
├─────────────────────────────────────────────────────────┤
│ 后端服务层（Node.js + Fastify） │
│ ┌─────────────┐ ┌─────────────┐ ┌─────────────────┐ │
│ │ API 网关 │ │ 业务服务 │ │ 工具服务 │ │
│ │（路由/认证）│ │（签到/组队/兑换）│ │（定时任务/日志）│ │
│ └─────────────┘ └─────────────┘ └─────────────────┘ │
├─────────────────────────────────────────────────────────┤
│ 数据层（SQLite + Sequelize） │
│ ┌─────────────┐ ┌─────────────┐ ┌─────────────────┐ │
│ │ 数据模型 │ │ 事务管理 │ │ 数据迁移 │ │
│ │（表结构映射） │ │（ACID 保障） │ │（版本控制） │ │
│ └─────────────┘ └─────────────┘ └─────────────────┘ │
└─────────────────────────────────────────────────────────┘

## 1.2 技术栈选型（聚焦多端适配）

| 层级       | 技术选型                        | 选型理由                                                                  |
| ---------- | ------------------------------- | ------------------------------------------------------------------------- |
| 前端核心   | Vite + React 18                 | 组件化开发效率高，Vite 支持快速热更新，适配多端编译需求                   |
| 响应式适配 | Tailwind CSS + react-responsive | Tailwind 提供原子类快速适配多端样式；react-responsive 实现屏幕宽度判断    |
| 交互兼容   | react-event-listener            | 统一处理触摸（移动端）与鼠标（电脑端）事件，避免重复代码                  |
| 状态管理   | React Context + useReducer      | 轻量级全局状态管理，满足多端共用状态（如用户登录态、布局偏好）            |
| API 交互   | Axios                           | 统一请求拦截、响应处理，支持多端共用 API 封装                             |
| 后端框架   | Node.js + Fastify               | 高性能、插件化，适合多端 API 适配，支持中间件机制，开发体验优秀，易于扩展 |
| ORM 工具   | Sequelize                       | 封装 SQLite 操作，支持数据模型、事务与迁移，保障数据一致性                |
| 数据库     | SQLite 3                        | 轻量文件型数据库，无需独立服务，降低部署复杂度，适合中小型应用            |

## 1.3 各层核心职责

### 1.3.1 前端层（多端适配核心）

- 响应式适配层：
  - 屏幕判断：通过 react-responsive 区分 “移动端（≤768px）” 与 “电脑端（>768px）”；
  - 布局切换：电脑端默认加载 “窄屏布局”（最大宽度 480px，居中展示），提供 “切换宽屏” 按钮，切换后为 “多列宽屏布局”；
  - 偏好保存：将电脑端布局偏好（窄屏 / 宽屏）存入 localStorage，下次访问自动加载。
- 业务组件层：
  - 共用组件：签到按钮、商品卡片等核心组件多端复用，通过 Tailwind 样式适配不同终端；
  - 差异化组件：电脑端宽屏专用组件（如数据表格、批量筛选器）懒加载，减少移动端加载体积。
- 工具服务层：
  - API 封装：多端共用 API 请求函数，自动添加终端类型标识（deviceType=mobile/pc）用于日志统计；
  - 缓存管理：高频数据（签到状态、朴分余额）用 localStorage 缓存（10 分钟过期），减少重复请求；
  - 交互优化：移动端触摸反馈（按钮震动）、电脑端鼠标悬停提示，适配不同操作习惯。

### 1.3.2 后端服务层

- 复用核心业务逻辑：签到周期生成、组队次数限制、朴分过期清理等，无需针对终端开发差异化逻辑；
- API 统一适配：返回精简字段（减少移动端流量消耗），支持分页查询（避免电脑端长列表卡顿）；
- 认证兼容：支持 “账号密码”“手机号验证码” 两种登录方式，适配移动端快速登录与电脑端安全登录。

### 1.3.3 数据层

- 数据库表结构、ORM 模型与事务逻辑完全统一，确保 H5 与 Web 端数据实时同步；
- 保留性能优化：关键字段（用户 ID、签到周期、组队码）创建索引，批量操作（如朴分过期清理）用事务保障原子性。

# 2. 核心功能模块设计（多端适配细节）

## 2.1 模块清单与多端适配重点

| 模块     | 核心功能                     | 移动端（H5）适配                                                                                        | 电脑端适配（默认竖屏/可选宽屏）                                                            |
| -------- | ---------------------------- | ------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------ |
| 用户模块 | 注册/登录、个人信息展示      | 1. 登录表单简化：支持“手机号+验证码”快速登录；2. 个人信息页：垂直布局，补分余额置顶，触摸友好的编辑按钮 | 宽屏：与移动端一致；宽屏：左右两列（左：用户信息，右：补分明细），支持键盘 Tab 导航        |
| 签到模块 | 每日签到、签到历史、周期展示 | 1. 签到按钮：居中放大（≥60px×60px），点击有震动反馈；2. 历史记录：下拉刷新，分页加载                    | 宽屏：与移动端一致；宽屏：签到按钮居左，历史记录用表格（日期、补分、状态），支持按周期筛选 |
| 组队模块 | 创建组队、加入组队、我的组队 | 1. 组队码输入：弹出数字键盘，支持粘贴；2. 我的组队：垂直列表，滑动删除过期组队                          | 宽屏：与移动端一致；宽屏：组队列表用卡片布局（1 行 2 张），点击卡片弹窗展示成员详情        |
| 商品模块 | 商品列表、商品详情、兑换     | 1. 商品列表：1 列布局，图片懒加载；2. 兑换按钮：固定在详情底部，避免滑动丢失                            | 宽屏：与移动端一致；宽屏：商品列表 3 列网格，hover 显示详情弹窗，支持批量对比              |
| 补分模块 | 补分记录、过期提醒、余额展示 | 1. 过期提醒：红色角标+弹窗（登录触发）；2. 补分记录：垂直列表，按“收入/支出”筛选                        | 宽屏：与移动端一致；宽屏：补分记录用表格，支持按时间/类型排序，过期补分高亮标记            |

## 2.2 关键模块交互流程（以签到为例）

```
多端统一流程：
用户访问签到页 → 前端判断终端类型（移动端/电脑端）→ 加载对应布局 →
调用API查询当前签到状态 → 展示“已签到”/“未签到” →
未签到：用户点击签到按钮 → 后端处理签到逻辑（加朴分、记记录）→
前端更新状态（显示获得朴分、刷新余额）
```

多端差异点：
移动端：点击签到按钮有震动反馈，历史记录下拉刷新；
电脑端宽屏：点击签到按钮有 hover 变色，历史记录表格支持排序。

# 3. 数据库设计

## 3.1 核心表结构

- 参照 [003 数据库.md ](src="./003.md")

## 3.2 设计原则

- 可扩展性：预留 related_id/related_type 字段，支持后续新增业务（如任务奖励）无需改表；
- 数据一致性：通过外键约束（如 user_id 关联 users.id）避免孤儿数据，事务保障关键操作（如兑换扣分）原子性；
- 性能优化：高频查询字段（user_id、cycle_id、team_code）创建索引，减少全表扫描；
- 冗余平衡：合理冗余字段（如 exchanges 表存储 points，避免查询商品表），提升查询效率。

## ER 图？？

## 类图？？

# 4. 关键技术方案

## 4.1 多端布局适配方案（核心）

### 4.1.1 屏幕判断与布局切换（代码示例）

```js
// hooks/useDeviceLayout.js（自定义Hooks，多端共用）
import { useState, useEffect } from "react";
import { useMediaQuery } from "react-responsive";

export const useDeviceLayout = () => {
  // 检测屏幕宽度：≤768px为移动端，>768px为电脑端
  const isMobile = useMediaQuery({ maxWidth: 768 });
  // 电脑端布局状态：默认窄屏（mobile-like），可选宽屏（pc-wide）
  const [pcLayout, setPcLayout] = useState("mobile-like");
  // 终端类型：mobile/pc
  const deviceType = isMobile ? "mobile" : "pc";

  // 初始化：电脑端读取本地存储的布局偏好
  useEffect(() => {
    if (!isMobile) {
      const savedLayout = localStorage.getItem("pcLayout");
      if (savedLayout) setPcLayout(savedLayout);
    }
  }, [isMobile]);

  // 切换电脑端布局
  const togglePcLayout = () => {
    const newLayout = pcLayout === "mobile-like" ? "pc-wide" : "mobile-like";
    setPcLayout(newLayout);
    localStorage.setItem("pcLayout", newLayout); // 保存偏好
  };

  return { deviceType, pcLayout, togglePcLayout, isMobile };
};
```

### 4.1.2 布局组件渲染（代码示例）

```js
// App.jsx（根组件，多端入口）
import { useDeviceLayout } from "./hooks/useDeviceLayout";
// 导入不同布局组件
import MobileLayout from "./layouts/MobileLayout";
import PcNarrowLayout from "./layouts/PcNarrowLayout";
import PcWideLayout from "./layouts/PcWideLayout";

const App = () => {
  const { deviceType, pcLayout, togglePcLayout } = useDeviceLayout();

  // 渲染对应布局
  const renderLayout = () => {
    if (deviceType === "mobile") {
      return <MobileLayout />;
    }
    // 电脑端：根据布局状态渲染
    return pcLayout === "mobile-like" ? (
      <PcNarrowLayout toggleLayout={togglePcLayout} />
    ) : (
      <PcWideLayout toggleLayout={togglePcLayout} />
    );
  };

  return <div className="app-root">{renderLayout()}</div>;
};
```

## 4.2 组队次数限制方案（无 Redis，基于数据库）

- 通过 user_daily_operations 表记录用户每日组队操作次数，避免重复创建 / 加入：

```js
// services/teamService.js（后端组队业务逻辑）
async function canCreateTeam(userId) {
  const today = new Date().toISOString().split("T")[0]; // 格式：YYYY-MM-DD
  // 查询今日创建次数
  const record = await UserDailyOperation.findOne({
    where: {
      user_id: userId,
      operation_type: "team_create", // 操作类型：创建组队
      date: today,
    },
  });

  // 无记录：允许创建，新增记录
  if (!record) {
    await UserDailyOperation.create({
      user_id: userId,
      operation_type: "team_create",
      date: today,
      count: 1,
    });
    return true;
  }

  // 有记录：判断是否达上限（1次/日）
  return record.count < 1;
}

// 加入组队次数限制逻辑类似，仅operation_type改为'team_join'
```

## 4.3 朴分过期管理方案

- 过期时间计算：朴分获取时，按 “获取时间 → 最近季度末（3/6/9/12 月 31 日）” 确定过期日期，存入 point_records.expire_date；
- 过期提醒：用户登录时，前端查询未来 5 天内过期的朴分，有则弹出红色提醒；
- 自动清理：使用 node-schedule 定时任务，在每个季度末 23:59 执行过期朴分清理：

```js
// 定时任务：季度末清理过期朴分
schedule.scheduleJob('59 23 31 3,6,9,12 *', async () => {
  const today = new Date().toISOString().split('T')[0];
  // 事务保障清理逻辑原子性
  await sequelize.transaction(async (t) => {
    // 1. 查询所有过期朴分记录
    const expiredRecords = await PointRecord.findAll({
      where: {
        expire_date: { [Op.lte]: today },
        points: { [Op.gt]: 0 }, // 仅清理未消耗的正向朴分
        is_expired: 0 // 未标记过期
      },
      transaction:</doubaocanvas>
```
